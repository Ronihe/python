The four principles of object-oriented programming are encapsulation, abstraction, inheritance, and polymorphism.

## Encapsulation:

Encapsulation is the mechanism of binding the data together and hiding it from the outside world. Encapsulation is achieved when each object keeps its state private so that other objects don’t have direct access to its state. Instead, they can access this state only through a set of public functions.

## Abstraction:

Abstraction can be thought of as the natural extension of encapsulation. It means hiding all but the relevant data about an object in order to reduce the complexity of the system. In a large system, objects talk to each other, which makes it difficult to maintain a large code base; abstraction helps by hiding internal implementation details of objects and only revealing operations that are relevant to other objects.

## Inheritance:

Inheritance is the mechanism of creating new classes from existing ones.

## Polymorphism:

Polymorphism (from Greek, meaning “many forms”) is the ability of an object to take different forms and thus, depending upon the context, to respond to the same message in different ways. Take the example of a chess game; a chess piece can take many forms, like bishop, castle, or knight and all these pieces will respond differently to the ‘move’ message.

## The process of OO analysis and design can be described as:

1. Identifying the objects in a system;
2. Defining relationships between objects;
3. Establishing the interface of each object(An interface is a description of the actions that an object can do) and,
4. Making a design, which can be converted to executables using OO languages.

## UML diagram:

structural diagrams and behavioral or interaction diagrams.

- Structural UML diagrams
  Class diagram
  Object diagram
  Package diagram
  Component diagram
  Composite structure diagram
  Deployment diagram
  Profile diagram

- Behavioral UML diagrams
  Use case diagram
  Activity diagram
  Sequence diagram
  State diagram
  Communication diagram
  Interaction overview diagram
  Timing diagram

**Use Case Diagram**: Used to describe a set of user scenarios, this diagram, illustrates the functionality provided by the system.

Class Diagram: Used to describe structure and behavior in the use cases, this diagram provides a conceptual model of the system in terms of entities and their relationships.

Activity Diagram: Used to model the functional flow-of-control between two or more class objects.

Sequence Diagram: Used to describe interactions among classes in terms of an exchange of messages over time.


